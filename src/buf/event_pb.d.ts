// @generated by protoc-gen-es v1.7.2
// @generated from file ingestion/v1alpha/event.proto (package ingestion.v1alpha, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage, Timestamp } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Event represents a every possible ingestion case.
 *
 * @generated from message ingestion.v1alpha.Event
 */
export declare class Event extends Message<Event> {
  /**
   * (Required) Unique identifier for the event
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * (Required) The type of event data
   * One of followings:
   * - session_open: Session is opened. Must send this event to analyze the session properly.
   * - message_create: Message is created. Must send this event to append message to the session.
   * - session_close: Session is closed. Recommend to send this event when you know session is explicitly closed. If not, impaction.ai will automatically close inactive sessions. (Inactive: no message for 30 minutes)
   * - user_recognize: User recognized. Must send this event to analyze user properly.
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * (Required) Event generation time
   *
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * (Required) Event properties
   *
   * @generated from field: ingestion.v1alpha.EventProperties properties = 4;
   */
  properties?: EventProperties;

  /**
   * (Required) Unique identifier for the project
   *
   * @generated from field: string project_id = 5;
   */
  projectId: string;

  constructor(data?: PartialMessage<Event>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ingestion.v1alpha.Event";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event;

  static equals(a: Event | PlainMessage<Event> | undefined, b: Event | PlainMessage<Event> | undefined): boolean;
}

/**
 * Client must set one of the following properties according to the event type.
 * Reserved properties:
 *   - session_open: SessionProperties
 *   - message_create: MessageProperties
 *   - session_close: SessionProperties
 *   - user_recognize: UserProperties
 *
 * @generated from message ingestion.v1alpha.EventProperties
 */
export declare class EventProperties extends Message<EventProperties> {
  /**
   * @generated from oneof ingestion.v1alpha.EventProperties.reserved_properties
   */
  reservedProperties: {
    /**
     * @generated from field: ingestion.v1alpha.EventProperties.SessionProperties session_properties = 1;
     */
    value: EventProperties_SessionProperties;
    case: "sessionProperties";
  } | {
    /**
     * @generated from field: ingestion.v1alpha.EventProperties.MessageProperties message_properties = 2;
     */
    value: EventProperties_MessageProperties;
    case: "messageProperties";
  } | {
    /**
     * @generated from field: ingestion.v1alpha.EventProperties.UserProperties user_properties = 3;
     */
    value: EventProperties_UserProperties;
    case: "userProperties";
  } | {
    /**
     * @generated from field: ingestion.v1alpha.EventProperties.FeedbackProperties feedback_properties = 4;
     */
    value: EventProperties_FeedbackProperties;
    case: "feedbackProperties";
  } | { case: undefined; value?: undefined };

  /**
   * Custom properties
   * Key must be unique and only contains alphanumeric characters and underscores.
   * Key cannot start with a number.
   *
   * @generated from field: map<string, ingestion.v1alpha.EventProperties.CustomPropertyValue> custom_properties = 10;
   */
  customProperties: { [key: string]: EventProperties_CustomPropertyValue };

  constructor(data?: PartialMessage<EventProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ingestion.v1alpha.EventProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventProperties;

  static equals(a: EventProperties | PlainMessage<EventProperties> | undefined, b: EventProperties | PlainMessage<EventProperties> | undefined): boolean;
}

/**
 * @generated from message ingestion.v1alpha.EventProperties.SessionProperties
 */
export declare class EventProperties_SessionProperties extends Message<EventProperties_SessionProperties> {
  /**
   * (Required) Unique identifier for the session
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * Title of the session
   *
   * @generated from field: string session_title = 2;
   */
  sessionTitle: string;

  /**
   * Start time of the session
   * Optional, but recommended to provide.
   *
   * @generated from field: google.protobuf.Timestamp session_start_time = 3;
   */
  sessionStartTime?: Timestamp;

  /**
   * (Required) User id of the session participant
   *
   * @generated from field: string user_id = 4;
   */
  userId: string;

  /**
   * (Required) Assistant id of session participant
   *
   * @generated from field: string assistant_id = 5;
   */
  assistantId: string;

  constructor(data?: PartialMessage<EventProperties_SessionProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ingestion.v1alpha.EventProperties.SessionProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventProperties_SessionProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventProperties_SessionProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventProperties_SessionProperties;

  static equals(a: EventProperties_SessionProperties | PlainMessage<EventProperties_SessionProperties> | undefined, b: EventProperties_SessionProperties | PlainMessage<EventProperties_SessionProperties> | undefined): boolean;
}

/**
 * @generated from message ingestion.v1alpha.EventProperties.MessageProperties
 */
export declare class EventProperties_MessageProperties extends Message<EventProperties_MessageProperties> {
  /**
   * (Required) Unique identifier for the session
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * Unique identifier for the message. This data only used for hint.
   *
   * @generated from field: string message_id_hint = 2;
   */
  messageIdHint: string;

  /**
   * (Required) Message index in the session.
   *
   * @generated from field: int32 message_index_hint = 3;
   */
  messageIndexHint: number;

  /**
   * (Required) Role of the speaker
   *
   * @generated from field: ingestion.v1alpha.EventProperties.MessageProperties.Role message_role = 4;
   */
  messageRole: EventProperties_MessageProperties_Role;

  /**
   * (Required) Content of the message
   *
   * @generated from field: string message_content = 5;
   */
  messageContent: string;

  /**
   * Message creation time
   * Optional, but recommended to provide.
   *
   * @generated from field: google.protobuf.Timestamp message_create_time = 6;
   */
  messageCreateTime?: Timestamp;

  constructor(data?: PartialMessage<EventProperties_MessageProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ingestion.v1alpha.EventProperties.MessageProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventProperties_MessageProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventProperties_MessageProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventProperties_MessageProperties;

  static equals(a: EventProperties_MessageProperties | PlainMessage<EventProperties_MessageProperties> | undefined, b: EventProperties_MessageProperties | PlainMessage<EventProperties_MessageProperties> | undefined): boolean;
}

/**
 * @generated from enum ingestion.v1alpha.EventProperties.MessageProperties.Role
 */
export declare enum EventProperties_MessageProperties_Role {
  /**
   * @generated from enum value: ROLE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ROLE_USER = 1;
   */
  USER = 1,

  /**
   * @generated from enum value: ROLE_ASSISTANT = 2;
   */
  ASSISTANT = 2,
}

/**
 * All fields except user_id are optional but at least one field must be set.
 *
 * @generated from message ingestion.v1alpha.EventProperties.UserProperties
 */
export declare class EventProperties_UserProperties extends Message<EventProperties_UserProperties> {
  /**
   * (Required) Unique identifier for the user
   *
   * @generated from field: string user_id = 1;
   */
  userId: string;

  /**
   * User's email address
   * Optional, but recommended to provide.
   *
   * @generated from field: string user_email = 2;
   */
  userEmail: string;

  /**
   * User's IP address
   * Optional, but recommended to provide one of user_ip and user_location.
   *
   * @generated from field: string user_ip = 3;
   */
  userIp: string;

  /**
   * User's location
   * If you omit this field, impaction.ai will try to extract location from the IP address
   *
   * @generated from field: ingestion.v1alpha.EventProperties.UserProperties.Location user_location = 4;
   */
  userLocation?: EventProperties_UserProperties_Location;

  /**
   * User creation time
   * Optional, but recommended to provide.
   *
   * @generated from field: google.protobuf.Timestamp user_create_time = 5;
   */
  userCreateTime?: Timestamp;

  /**
   * User's display name
   * Usually, use legal name or nickname of the user
   * Optional, but recommended to provide.
   *
   * @generated from field: string user_display_name = 6;
   */
  userDisplayName: string;

  constructor(data?: PartialMessage<EventProperties_UserProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ingestion.v1alpha.EventProperties.UserProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventProperties_UserProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventProperties_UserProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventProperties_UserProperties;

  static equals(a: EventProperties_UserProperties | PlainMessage<EventProperties_UserProperties> | undefined, b: EventProperties_UserProperties | PlainMessage<EventProperties_UserProperties> | undefined): boolean;
}

/**
 * @generated from message ingestion.v1alpha.EventProperties.UserProperties.Location
 */
export declare class EventProperties_UserProperties_Location extends Message<EventProperties_UserProperties_Location> {
  /**
   * ISO-3166-1 alpha-2 code of the country
   *
   * @generated from field: string country_code = 1;
   */
  countryCode: string;

  /**
   * State name
   *
   * @generated from field: string state = 2;
   */
  state: string;

  /**
   * City name
   *
   * @generated from field: string city = 3;
   */
  city: string;

  constructor(data?: PartialMessage<EventProperties_UserProperties_Location>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ingestion.v1alpha.EventProperties.UserProperties.Location";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventProperties_UserProperties_Location;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventProperties_UserProperties_Location;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventProperties_UserProperties_Location;

  static equals(a: EventProperties_UserProperties_Location | PlainMessage<EventProperties_UserProperties_Location> | undefined, b: EventProperties_UserProperties_Location | PlainMessage<EventProperties_UserProperties_Location> | undefined): boolean;
}

/**
 * @generated from message ingestion.v1alpha.EventProperties.FeedbackProperties
 */
export declare class EventProperties_FeedbackProperties extends Message<EventProperties_FeedbackProperties> {
  /**
   * (Required) Unique identifier for the session
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * (Required) Target resource of the feedback
   *
   * @generated from field: ingestion.v1alpha.EventProperties.FeedbackProperties.Target feedback_target = 2;
   */
  feedbackTarget: EventProperties_FeedbackProperties_Target;

  /**
   * (Required) Score of the feedback. 0
   *
   * @generated from field: int32 feedback_score = 3;
   */
  feedbackScore: number;

  /**
   * Unique identifier for the message. This data only used for hint.
   *
   * @generated from field: string message_id_hint = 4;
   */
  messageIdHint: string;

  /**
   * Message index in the session.
   * Required if feedback_target is TARGET_MESSAGE.
   *
   * @generated from field: int32 message_index_hint = 5;
   */
  messageIndexHint: number;

  constructor(data?: PartialMessage<EventProperties_FeedbackProperties>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ingestion.v1alpha.EventProperties.FeedbackProperties";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventProperties_FeedbackProperties;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventProperties_FeedbackProperties;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventProperties_FeedbackProperties;

  static equals(a: EventProperties_FeedbackProperties | PlainMessage<EventProperties_FeedbackProperties> | undefined, b: EventProperties_FeedbackProperties | PlainMessage<EventProperties_FeedbackProperties> | undefined): boolean;
}

/**
 * @generated from enum ingestion.v1alpha.EventProperties.FeedbackProperties.Target
 */
export declare enum EventProperties_FeedbackProperties_Target {
  /**
   * @generated from enum value: TARGET_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * TARGET_SESSION represents the feedback is for the entire session.
   *
   * @generated from enum value: TARGET_SESSION = 1;
   */
  SESSION = 1,

  /**
   * TARGET_MESSAGE represents the feedback is for a specific message in the session.
   *
   * @generated from enum value: TARGET_MESSAGE = 2;
   */
  MESSAGE = 2,
}

/**
 * @generated from message ingestion.v1alpha.EventProperties.CustomPropertyValue
 */
export declare class EventProperties_CustomPropertyValue extends Message<EventProperties_CustomPropertyValue> {
  /**
   * Value can have maximum 256 characters.
   *
   * @generated from field: string string_value = 1;
   */
  stringValue: string;

  constructor(data?: PartialMessage<EventProperties_CustomPropertyValue>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "ingestion.v1alpha.EventProperties.CustomPropertyValue";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventProperties_CustomPropertyValue;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventProperties_CustomPropertyValue;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventProperties_CustomPropertyValue;

  static equals(a: EventProperties_CustomPropertyValue | PlainMessage<EventProperties_CustomPropertyValue> | undefined, b: EventProperties_CustomPropertyValue | PlainMessage<EventProperties_CustomPropertyValue> | undefined): boolean;
}

